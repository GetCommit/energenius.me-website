(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = global || self, global['react-paginating-umd'] = factory(global.React));
}(this, function (React) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function getRange(start, end) {
    return _toConsumableArray(Array(end - start + 1)).map(function (_, i) {
      return start + i;
    });
  }
  function getPageInfo(_ref) {
    var limit = _ref.limit,
        pageCount = _ref.pageCount,
        total = _ref.total,
        page = _ref.page;
    var totalPages = Math.ceil(total / limit);
    var totalResults = parseInt(total, 10);
    var currentPage = parseInt(page, 10);

    if (currentPage < 1) {
      currentPage = 1;
    }

    if (currentPage > totalPages) {
      currentPage = totalPages;
    }

    var firstPage = Math.max(1, currentPage - Math.floor(pageCount / 2));
    var lastPage = Math.min(totalPages, currentPage + Math.floor(pageCount / 2));

    if (lastPage - firstPage + 1 < pageCount) {
      if (currentPage < totalPages / 2) {
        lastPage = Math.min(totalPages, lastPage + (pageCount - (lastPage - firstPage)));
      } else {
        firstPage = Math.max(1, firstPage - (pageCount - (lastPage - firstPage)));
      }
    }

    if (lastPage - firstPage + 1 > pageCount) {
      if (currentPage > totalPages / 2) {
        // eslint-disable-next-line
        firstPage++;
      } else {
        // eslint-disable-next-line
        lastPage--;
      }
    }

    var firstResult = limit * (currentPage - 1);
    var lastResult = limit * currentPage - 1;
    return {
      totalPages: totalPages,
      pages: Math.min(lastPage - firstPage + 1, totalPages),
      currentPage: currentPage,
      firstPage: firstPage,
      lastPage: lastPage,
      previousPage: currentPage - 1,
      nextPage: currentPage + 1,
      hasPreviousPage: currentPage > 1,
      hasNextPage: currentPage < totalPages,
      totalResults: totalResults,
      results: Math.min(lastResult - firstResult + 1, totalResults),
      firstResult: firstResult,
      lastResult: lastResult
    };
  }

  function Pagination(props) {
    var _useState = React.useState(1),
        _useState2 = _slicedToArray(_useState, 2),
        currentPage = _useState2[0],
        setCurrentPage = _useState2[1];

    if (props.currentPage && currentPage !== props.currentPage) {
      setCurrentPage(parseInt(props.currentPage, 10));
    }

    var _getPageItemProps = function _getPageItemProps(props) {
      var pageValue = props.pageValue,
          handlePageChange = props.onPageChange,
          rest = _objectWithoutProperties(props, ["pageValue", "onPageChange"]);

      var onPageChange = function onPageChange(e) {
        if (typeof handlePageChange === 'function') {
          handlePageChange(pageValue, e);
        }

        setCurrentPage(pageValue);
      };

      return _objectSpread({
        onClick: onPageChange
      }, rest);
    };

    var total = props.total,
        limit = props.limit,
        pageCount = props.pageCount;
    var pageInfo = getPageInfo({
      limit: limit,
      pageCount: pageCount,
      total: total,
      page: currentPage
    });
    var firstPage = pageInfo.firstPage,
        lastPage = pageInfo.lastPage,
        hasNextPage = pageInfo.hasNextPage,
        hasPreviousPage = pageInfo.hasPreviousPage,
        previousPage = pageInfo.previousPage,
        nextPage = pageInfo.nextPage,
        totalPages = pageInfo.totalPages;
    var pages = total ? getRange(firstPage, lastPage) : [];
    return React__default.createElement("div", null, props.children({
      pages: pages,
      previousPage: previousPage,
      nextPage: nextPage,
      totalPages: totalPages,
      currentPage: currentPage,
      hasNextPage: hasNextPage,
      hasPreviousPage: hasPreviousPage,
      getPageItemProps: _getPageItemProps
    }));
  }

  return Pagination;

}));
//# sourceMappingURL=react-paginating.umd.js.map
